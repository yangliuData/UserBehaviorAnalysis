    在UniqueVisitor.class例子中，我们把所有数据的userId都存在了窗口计算的状态里，在窗口收集数据的过程中，状态会不断增大。一般情况下，只要不超过内存的承受范围，这种做法也没什么问题；但如果我们遇到的数据量很大呢？
    
    把所有数据暂存放内存里，显然不是一个好主意。我们会想到，可以利用redis这种内存级k-v数据库，为我们做个一个缓存。但如果我们遇到的情况非常极端，数据大到惊人呢？比如上亿级的用户，要去重计算UV。
    
    如果放到redis中，亿级的用户id（每个20个字节左右的话）可能需要几个G甚至十几个G的空间来存储。当然放到redis中，用集群进行扩展也不是不可以，但明显代价太大了。
    
    一个更好的想法是，其实我们不需要完整地存储用户ID的信息，只要知道他在不在就行了。所以其实我们可以进行压缩处理，用一位（bit）就可以表示一个用户的状态。这个思想的具体实现就是布隆过滤器。
    
    本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构，特点是搞笑地插入和查询，可以用来告诉你'某样东西一定不存在或者可能存在'。
    
    它本身是一个很长的二进制向量，既然是二进制的向量，那么显而易见的，存放的不是0，就是1。相比于传统的List、Set、Map等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。
    
    我们的目标就是，利用某种方法（一般是Hash函数）把每个数据，对应到一个位图的某一位上去；如果数据存在，那一位就是1，不存在则是0。
    
    问题1：什么是Hash碰撞？
    2：怎么解决Hash碰撞。
    3：布隆过滤器的原理？